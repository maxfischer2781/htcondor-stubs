from typing import (
    Any,
    overload,
    Literal as TpLiteral,
    Iterator,
    TextIO,
    Callable,
    ClassVar,
    Mapping,
    Iterable,
)
from warnings import deprecated
import enum
import datetime

class Value(enum.IntEnum):
    Error = 1
    Undefined = 2
    names: ClassVar[dict[str, Value]]
    values: ClassVar[dict[int, Value]]

# for typing convenience
type ERROR = TpLiteral[Value.Error]
type UNDEFINED = TpLiteral[Value.Undefined]
type _EU = ERROR | UNDEFINED

type PyValue[V: PyValue] = PyConstant | PyCollection[V]
# Integer, Real, String, Boolean, AbsTime, RelTime, Undefined, Error,
type PyConstant = int | float | str | bool | datetime.datetime | float | ERROR | UNDEFINED
# List, Record
type PyCollection[V: PyValue] = list[V] | dict[str, V]

class ExprTree[V: PyValue[Any]]:
    @overload
    def __init__[EV: PyValue[Any]](self: ExprTree[EV], expr: ExprTree[EV]) -> None: ...
    @overload
    def __init__(self: ExprTree[Any], expr: str) -> None: ...
    # TODO: Encode full ClassAd operator domain relations
    def __add__[OV: PyValue[Any]](
        self, other: ExprTree[OV] | OV
    ) -> ExprTree[V | OV | _EU]: ...
    def __sub__[OV: PyValue[Any]](
        self, other: ExprTree[OV] | OV
    ) -> ExprTree[V | OV | _EU]: ...
    def __mul__[OV: PyValue[Any]](
        self, other: ExprTree[OV] | OV
    ) -> ExprTree[V | OV | _EU]: ...
    def __truediv__[OV: PyValue[Any]](
        self, other: ExprTree[OV] | OV
    ) -> ExprTree[V | OV | _EU]: ...
    def __mod__[OV: PyValue[Any]](
        self, other: ExprTree[OV] | OV
    ) -> ExprTree[V | OV | _EU]: ...
    def __lshift[OV: PyValue[Any]](
        self, other: ExprTree[OV] | OV
    ) -> ExprTree[V | OV | _EU]: ...
    def __rshift[OV: PyValue[Any]](
        self, other: ExprTree[OV] | OV
    ) -> ExprTree[V | OV | _EU]: ...
    def __and__[OV: PyValue[Any]](
        self, other: ExprTree[OV] | OV
    ) -> ExprTree[V | OV | _EU]: ...
    def __or__[OV: PyValue[Any]](
        self, other: ExprTree[OV] | OV
    ) -> ExprTree[V | OV | _EU]: ...
    def __xor__[OV: PyValue[Any]](
        self, other: ExprTree[OV] | OV
    ) -> ExprTree[V | OV | _EU]: ...
    def __getitem__[LV: PyValue[Any]](self: ExprTree[list[LV]], key: int) -> V: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: ExprTree[Any] | PyValue[Any]) -> ExprTree[bool | _EU]: ...
    def __ne__(self, other: ExprTree[Any] | PyValue[Any]) -> ExprTree[bool | _EU]: ...
    def __ge__(self, other: ExprTree[Any] | PyValue[Any]) -> ExprTree[bool | _EU]: ...
    def __gt__(self, other: ExprTree[Any] | PyValue[Any]) -> ExprTree[bool | _EU]: ...
    def __le__(self, other: ExprTree[Any] | PyValue[Any]) -> ExprTree[bool | _EU]: ...
    def __lt__(self, other: ExprTree[Any] | PyValue[Any]) -> ExprTree[bool | _EU]: ...
    def and_[OV: PyValue[Any]](
        self, expr: ExprTree[OV] | OV
    ) -> ExprTree[V | OV | _EU]: ...
    def or_[OV: PyValue[Any]](
        self, expr: ExprTree[OV] | OV
    ) -> ExprTree[V | OV | _EU]: ...
    def is_(self, expr: ExprTree[Any] | PyValue[Any]) -> ExprTree[bool]: ...
    def isnt_(self, expr: ExprTree[Any] | PyValue[Any]) -> ExprTree[bool]: ...
    def sameAs(self, expr: ExprTree[Any] | PyValue[Any]) -> ExprTree[bool]: ...
    def eval(
        self,
        scope: ClassAd[Any] | None = None,
    ) -> V | _EU: ...
    @overload
    def simplify(self) -> ExprTree[V]: ...
    @overload
    def simplify(self, scope: ClassAd[Any] | None) -> ExprTree[V]: ...
    @overload
    def simplify(
        self, scope: ClassAd[Any] | None, target: ClassAd[Any] | None
    ) -> ExprTree[V]: ...

# Not a Mapping/MutableMapping!
class ClassAd[V: PyValue[Any]]:
    @overload
    def __init__[CV: PyValue[Any]](self: ClassAd[CV], input: ClassAd[CV]) -> None: ...
    @overload
    def __init__[DV: PyValue[Any]](
        self: ClassAd[DV],
        input: (
            Mapping[str, DV | ExprTree[DV]] | Iterable[tuple[str, DV | ExprTree[DV]]]
        ),
    ) -> None: ...
    @overload
    def __init__[DV: PyValue[Any], DDV: PyValue[Any]](
        self: ClassAd[DV | dict[str, DDV]],
        input: (
            Mapping[str, DV | ExprTree[DV] | Mapping[str, ClassAd[DDV]]]
            | Iterable[tuple[str, DV | ExprTree[DV]] | Mapping[str, ClassAd[DDV]]]
        ),
    ) -> None: ...
    @overload
    def __init__(self: ClassAd[Any], input: str) -> None: ...
    @overload
    def __init__(self: ClassAd[Any]) -> None: ...
    def __contains__(self, key: str) -> bool: ...
    def __getitem__(self, key: str) -> V: ...
    def __setitem__(self, key: str, value: V) -> bool: ...
    def __delitem__(self, key: str) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[str]: ...
    def __eq__(self, other: ClassAd[Any]) -> bool: ...
    def __ne__(self, other: ClassAd[Any]) -> bool: ...
    def eval(self, attr: str) -> V: ...
    def lookup(self, attr: str) -> ExprTree[V]: ...
    def printOld(self) -> str: ...
    def printJson(self) -> str: ...
    def flatten(self, expr: ExprTree[V]) -> ExprTree[V]: ...
    def matches(self, ad: ClassAd[Any]) -> bool: ...
    def symmetricMatch(self, ad: ClassAd[Any]) -> bool: ...
    def externalRefs(self, expr: ExprTree[Any]) -> list[str]: ...
    def internalRefs(self, expr: ExprTree[Any]) -> list[str]: ...
    # dict-like methods
    def keys(self) -> Iterator[str]: ...
    def values(self) -> Iterator[V]: ...
    def items(self) -> Iterator[tuple[str, V]]: ...
    @overload
    def get(self, key: str, default: None = None) -> V | None: ...
    @overload
    def get[D](self, key: str, default: D) -> V | D: ...
    @overload
    def setdefault(self, key: str, default: None = None) -> V | UNDEFINED: ...
    @overload
    def setdefault(self, key: str, default: V) -> V: ...
    # same types as __init__
    @overload
    def update[CV: PyValue[Any]](self: ClassAd[CV], other: ClassAd[CV], /) -> None: ...
    @overload
    def update[DV: PyValue[Any]](
        self: ClassAd[DV],
        other: dict[str, DV | ExprTree[DV]] | Iterable[tuple[str, DV | ExprTree[DV]]],
        /,
    ) -> None: ...
    @overload
    def update[DV: PyValue[Any], DDV: PyValue[Any]](
        self: ClassAd[DV | dict[str, DDV]],
        other: (
            Mapping[str, DV | ExprTree[DV] | Mapping[str, ClassAd[DDV]]]
            | Iterable[tuple[str, DV | ExprTree[DV]] | Mapping[str, ClassAd[DDV]]]
        ),
        /,
    ) -> None: ...

def parseAds(
    input: str | TextIO, parser: Parser = Parser.Auto
) -> Iterator[ClassAd[Any]]: ...
def parseNext(input: str | TextIO, parser: Parser = Parser.Auto) -> ClassAd[Any]: ...
def parseOne(input: str | TextIO, parser: Parser = Parser.Auto) -> ClassAd[Any]: ...
def quote(input: str) -> str: ...
def unquote(input: str) -> str: ...
def Attribute(name: str) -> ExprTree[Any]: ...
def Function(name: str, *args: str) -> ExprTree[Any]: ...
def Literal[O: int | float | bool | str](obj: O) -> ExprTree[O]: ...
def lastError() -> str: ...
def register(
    function: Callable[..., PyValue[Any]], name: str | None = None
) -> None: ...
def registerLibrary(arg1: str, /) -> None: ...

class Parser(enum.IntEnum):
    Auto = 1
    Old = 2
    New = 3
    names: ClassVar[dict[str, Parser]]
    values: ClassVar[dict[int, Parser]]

def version() -> str: ...

class ClassAdException(Exception, BaseException, object): ...
class ClassAdEnumError(ClassAdException, TypeError): ...
class ClassAdEvaluationError(ClassAdException, TypeError, RuntimeError): ...
class ClassAdInternalError(ClassAdException, ValueError, RuntimeError): ...
class ClassAdParseError(ClassAdException, ValueError, SyntaxError, RuntimeError): ...
class ClassAdValueError(ClassAdException, ValueError, RuntimeError, TypeError): ...
class ClassAdTypeError(ClassAdException, TypeError, ValueError): ...
class ClassAdOSError(ClassAdException, OSError, RuntimeError): ...

@deprecated("use classad.parseNext(…, classad.Parser.New) instead")
def parse(input: str | TextIO) -> ClassAd[Any]: ...
@deprecated("use classad.parseNext(…, classad.Parser.Old) instead")
def parseOld(input: str | TextIO) -> ClassAd[Any]: ...
